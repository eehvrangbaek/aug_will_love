"""Module responsible for drawing graphs"""
from typing import Dict, List, TypeVar

import networkx as nx
import numpy as np
import plotly.graph_objects as go
from community import community_louvain
from gensim.models import Word2Vec
from networkx.drawing.layout import spring_layout

from latin import remove_stopwords

T = TypeVar("T")


def distinct(elements: List[T]) -> List[T]:
    """
    Function that takes a list and transforms it into a list of unique values,
    similar to SQL's DISTINCT command
    """
    return list(set(elements))


def most_similar(word: str, topn: int, model: Word2Vec) -> List[str]:
    """
    Returns the n most similar words to word in the model's vocabulary
    """
    return [word for word, _ in model.wv.most_similar(positive=[word], topn=topn)]


def distance_matrix(tokens: List[str], model: Word2Vec) -> np.ndarray:
    """
    Calculates the delta distance matrix for tokens
    based on the vectors generated by the Word2Vec model
    """
    word_vectors = model.wv
    matrix = np.zeros((len(tokens), len(tokens)))
    for i, token in enumerate(tokens):
        # calculates distance of one certain token to every other one
        matrix[i, :] = word_vectors.distances(token, tokens)
    # delete edges between the token and itself
    np.fill_diagonal(matrix, 0.0)
    # Zeroes out connections that are over median distance
    # this way the graph doesn't become a mess when a lot of nodes are added
    cond = np.median(matrix)
    zero = np.zeros_like(matrix)
    matrix = np.where(matrix > cond, zero, matrix)
    return matrix


def get_graph(seeds: List[str], model: Word2Vec, k: int, m: int) -> Dict:
    """
    Obtains graph labels, edges, node positions, colors and connections for a semantic graph
    based on the seeds and a word2vec model.
    k corresponds to the number of words to be yielded from 1st level association, while
    m corresponds to the number of words to be yielded from the 2nd level association step.
    """
    types = []
    for seed in seeds:
        types.extend(most_similar(seed, k, model))
        types.append(seed)
    types = distinct(types)
    tokens = []
    for source in types:
        tokens.extend(most_similar(source, m, model))
        tokens.append(source)
    tokens = distinct(tokens)
    tokens = remove_stopwords(tokens)
    labels = [token.upper() if token in types else token.lower() for token in tokens]
    delta = distance_matrix(tokens, model)
    connections = np.sum(delta != 0, axis=1)
    delta = delta * 10  # scale
    dt = [("len", float)]
    delta = delta.view(dt)
    G = nx.from_numpy_matrix(delta)
    pos = spring_layout(nx.from_numpy_matrix(delta))
    parts = community_louvain.best_partition(G)
    colors = list(parts.values())
    edges = np.array(G.edges())
    return {
        "labels": labels,
        "edges": edges,
        "pos": pos,
        "colors": colors,
        "connections": connections,
    }


def get_edge_pos(edges: np.ndarray, x_y: np.ndarray) -> np.ndarray:
    """
    Through a series of nasty numpy tricks, that IÂ® wrote
    this function transforms edges and either the x or the y positions of nodes to
    the x or y positions for the lines in the plotly figure.
    In order for the line not to be connected, the algorithm
    has to insert a nan value after each pair of points that have to be connected.
    """
    edges = np.array(edges)
    x_y = np.array(x_y)
    a = x_y[edges]
    a.shape
    b = np.zeros((a.shape[0], a.shape[1] + 1))
    b[:, :-1] = a
    b[:, -1] = np.nan
    return b.flatten()


def produce_annotations(
    labels: List[str], x: np.ndarray, y: np.ndarray, size
) -> List[Dict]:
    annotations = []
    for i, label in enumerate(labels):
        annotations.append(
            dict(
                text=label,
                x=x[i],
                y=y[i],
                showarrow=False,
                xanchor="center",
                bgcolor="rgba(255,255,255,0.5)",
                bordercolor="rgba(0,0,0,0.5)",
                font={
                    "family": "Helvetica",
                    "size": max(size[i], 10),
                    "color": "black",
                },
            )
        )
    return annotations


def build_plot(graph: Dict, style: str) -> go.Figure:  # type: ignore
    """
    Builds Plotly plot object based on the graph dictionary
    yielded by get_graph, and the style value which could
    either be sej or kedelig.
    """
    # Unzipping pos tuples
    x, y = zip(*graph["pos"].values())
    # Turning x and y to numpy arrays
    x, y = np.array(x), np.array(y)
    # Calculating edge positions
    edges_x = get_edge_pos(graph["edges"], x)
    edges_y = get_edge_pos(graph["edges"], y)
    # Turning number of connections into a numpy array
    graph["connections"] = np.array(graph["connections"])
    # Normalizing number of connections and then calculating node size from it
    # Note: only in effect when style is "sej"
    sum_connections = np.sum(graph["connections"])
    size = 100 * graph["connections"] / sum_connections
    indices = np.arange(len(x))
    # Setting some parameters differntly for differen styles
    if style == "sej":
        annotations = produce_annotations(graph["labels"], x, y, size)
        display_mode = "markers"
        textposition = None
        marker_size = 10 * size
    else:
        annotations = None
        display_mode = "markers+text"
        textposition = "top center"
        marker_size = 10

    node_trace = go.Scatter(
        x=x,
        y=y,
        mode=display_mode,
        hoverinfo="text",
        text=graph["labels"],
        textposition=textposition,
        marker={
            "colorscale": "sunsetdark",
            "reversescale": True,
            "color": graph["colors"],
            "size": marker_size,
            "line_width": 2,
        },
        customdata=indices,
    )

    edge_trace = go.Scatter(
        x=edges_x,
        y=edges_y,
        line=dict(width=0.5, color="#888"),
        hoverinfo="none",
        mode="lines",
    )
    fig = go.Figure(
        data=[edge_trace, node_trace],
        layout=go.Layout(
            clickmode="event",
            annotations=annotations or [],
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            titlefont_size=16,
            showlegend=False,
            margin=dict(b=20, l=5, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        ),
    )
    return fig


def get_neighbours(graph: Dict, node_index: int) -> List[str]:
    """
    Returns all labels of a specific node's neighbours in the graph.
    Note that the function takes the node's index as its input.
    """
    labels = graph["labels"]
    edges = graph["edges"]
    neighbours = [j if i == node_index else i for i, j in edges if node_index in (i, j)]
    return [labels[i] for i in neighbours]
