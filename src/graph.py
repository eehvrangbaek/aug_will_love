import os
from typing import Dict, List

import networkx as nx
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from community import community_louvain
from gensim.models import Word2Vec
from networkx.drawing.layout import spring_layout


def distinct(l: List) -> List:
    """
    Function that takes a list and transforms it into a list of unique values,
    similar to SQL's DISTINCT command
    """
    return list(set(l))


def empty(s: str) -> bool:
    """
    Tells you whether a string is empty
    """
    return not s or not s.strip()


def most_similar(word: str, n: int, model: Word2Vec) -> List[str]:
    """
    Returns the n most similar words to word in the model's vocabulary
    """
    return [word for word, _ in model.wv.most_similar(positive=[word], topn=n)]


def distance_matrix(tokens: List[str], model: Word2Vec) -> np.ndarray:
    """
    Calculates the delta distance matrix for tokens based on the vectors generated by the Word2Vec model
    """
    word_vectors = model.wv
    matrix = np.zeros((len(tokens), len(tokens)))
    for i, token in enumerate(tokens):
        # calculates distance of one certain token to every other one
        matrix[i, :] = word_vectors.distances(token, tokens)
    # delete edges between the token and itself
    np.fill_diagonal(matrix, 0.0)
    # Zeroes out connections that are over median distance, this way the graph doesn't become a mess when a lot of nodes are added
    cond = np.median(matrix)
    zero = np.zeros_like(matrix)
    matrix = np.where(matrix > cond, zero, matrix)
    return matrix


def immediate_subdirectories(a_dir: str) -> List[str]:
    # print(os.getcwd())
    return [
        name for name in os.listdir(a_dir) if os.path.isdir(os.path.join(a_dir, name))
    ]


def get_graph(seeds: List[str], model: Word2Vec, k: int, m: int) -> Dict:
    """
    Obtains graph labels, edges, node positions, colors and connections for a semantic graph
    based on the seeds and a word2vec model.
    k corresponds to the number of words to be yielded from 1st level association, while
    m corresponds to the number of words to be yielded from the 2nd level association step.
    """
    types = []
    for seed in seeds:
        types.extend(most_similar(seed, k, model))
        types.append(seed)
    types = distinct(types)
    tokens = []
    for source in types:
        tokens.extend(most_similar(source, m, model))
        tokens.append(source)
    tokens = distinct(tokens)
    labels = [token.upper() if token in types else token.lower() for token in tokens]
    delta = distance_matrix(tokens, model)
    connections = np.sum(delta != 0, axis=1)
    delta = delta * 10  # scale
    dt = [("len", float)]
    delta = delta.view(dt)
    G = nx.from_numpy_matrix(delta)
    pos = spring_layout(nx.from_numpy_matrix(delta))
    parts = community_louvain.best_partition(G)
    colors = list(parts.values())
    edges = np.array(G.edges())
    return {
        "labels": labels,
        "edges": edges,
        "pos": pos,
        "colors": colors,
        "connections": connections,
    }


def get_edge_pos(edges: np.ndarray, x_y: np.ndarray) -> np.ndarray:
    """
    Through a series of nasty numpy tricks, that IÂ® wrote
    this function transforms edges and either the x or the y positions of nodes to
    the x or y positions for the lines in the plotly figure.
    In order for the line not to be connected, the algorithm has to insert a nan value after each pair of points that have to be connected.
    """
    edges = np.array(edges)
    x_y = np.array(x_y)
    a = x_y[edges]
    a.shape
    b = np.zeros((a.shape[0], a.shape[1] + 1))
    b[:, :-1] = a
    b[:, -1] = np.nan
    return b.flatten()


def build_plot(graph: Dict, style: str) -> go.Figure:
    """
    Builds Plotly plot object based on the graph dictionary yielded by get_graph, and the style value which could
    either be sej or kedelig.
    I only introduced this feature as I wanted to make cool looking graphs and Eva wanted to look at them,
    but she told me that they were perhaps too playful for academia, so now you cvan switch between the two in the app.
    """
    x, y = zip(*graph["pos"].values())
    x, y = np.array(x), np.array(y)
    edges_x = get_edge_pos(graph["edges"], x)
    edges_y = get_edge_pos(graph["edges"], y)
    sum_connections = np.sum(graph["connections"])
    graph["connections"] = np.array(graph["connections"])
    indices = list(range(len(x)))
    size = 100 * graph["connections"] / sum_connections
    if style == "sej":
        annotations = [
            dict(
                text=node,
                x=x[i],
                y=y[i],
                showarrow=False,
                xanchor="center",
                bgcolor="rgba(255,255,255,0.5)",
                bordercolor="rgba(0,0,0,0.5)",
                font={
                    "family": "Helvetica",
                    "size": max(size[i], 10),
                    "color": "black",
                },
            )
            for i, node in enumerate(graph["labels"])
        ]
    if style == "sej":
        node_trace = go.Scatter(
            x=x,
            y=y,
            mode="markers",
            hoverinfo="text",
            text=graph["labels"],
            marker={
                "colorscale": "sunsetdark",
                "reversescale": True,
                "color": graph["colors"],
                "size": 10 * size,
                "line_width": 2,
            },
            customdata=indices,
        )
    else:
        node_trace = go.Scatter(
            x=x,
            y=y,
            mode="markers+text",
            hoverinfo="text",
            text=graph["labels"],
            textposition="top center",
            marker={
                "colorscale": "sunsetdark",
                "reversescale": True,
                "color": graph["colors"],
                "size": 10,
                "line_width": 2,
            },
            customdata=indices,
        )
    edge_trace = go.Scatter(
        x=edges_x,
        y=edges_y,
        line=dict(width=0.5, color="#888"),
        hoverinfo="none",
        mode="lines",
    )
    fig = go.Figure(
        data=[edge_trace, node_trace],
        layout=go.Layout(
            clickmode="event",
            annotations=annotations if style == "sej" else [],
            paper_bgcolor="rgba(0,0,0,0)",
            plot_bgcolor="rgba(0,0,0,0)",
            titlefont_size=16,
            showlegend=False,
            margin=dict(b=20, l=5, r=5, t=40),
            xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
            yaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
        ),
    )
    return fig


def get_neighbours(graph: Dict, node: int) -> List[str]:
    """
    Returns all labels of a specific node's neighbours in the graph.
    Note that the function takes the node's index as its input.
    """
    labels = graph["labels"]
    edges = graph["edges"]
    neighbours = [j if i == node else i for i, j in edges if (i == node) or (j == node)]
    return [labels[i] for i in neighbours]
